"""
External MMM Knowledge Base

Industry best practices, benchmarks, and domain expertise.
"""

from typing import Dict, List
import logging

logger = logging.getLogger(__name__)


class MMMExpertise:
    """
    External knowledge base for MMM domain expertise.
    
    Includes:
    - Channel benchmarks (typical ROI, saturation levels)
    - Best practices (adstock windows, diminishing returns)
    - Academic research citations
    - Industry standards
    
    This knowledge supplements the RAG system with established MMM wisdom.
    """
    
    # MMM Terminology Glossary
    MMM_GLOSSARY = {
        'contribution': {
            'definition': 'The predicted response or sales generated by a marketing channel or activity',
            'formula': 'Contribution = Predicted Response from Model',
            'synonyms': ['predicted', 'predicted response', 'predicted sales', 'model output'],
            'context': 'In MMM, contribution refers to the sales/conversions/visits attributed to marketing by the model'
        },
        'incrementality': {
            'definition': 'Additional sales generated by marketing beyond what would have happened naturally (baseline)',
            'formula': 'Incrementality = Total Sales - Baseline',
            'synonyms': ['incremental', 'lift', 'additive effect'],
            'context': 'Measures the causal impact of marketing spend'
        },
        'baseline': {
            'definition': 'Sales that would occur without any marketing activity',
            'formula': 'Baseline = f(trend, seasonality, other non-marketing factors)',
            'synonyms': ['base sales', 'organic sales', 'non-marketing sales'],
            'context': 'Typically 30-60% of total sales in a healthy brand'
        },
        'saturation': {
            'definition': 'The spend level at which additional investment yields diminishing returns',
            'formula': 'Saturation Point = Spend where marginal ROI < threshold',
            'synonyms': ['saturation point', 'diminishing returns threshold', 'optimal spend'],
            'context': 'From Hill/logistic response curves - the inflection point'
        },
        'adstock': {
            'definition': 'Carryover effect where marketing impact persists beyond the initial exposure',
            'formula': 'Adstocked Spend = Current + decay × Previous',
            'synonyms': ['carryover', 'lagged effect', 'decay', 'memory effect'],
            'context': 'TV has longer adstock (2-6 weeks) than digital (1-2 weeks)'
        },
        'roi': {
            'definition': 'Return on Investment - revenue generated per dollar spent',
            'formula': 'ROI = Revenue / Spend',
            'synonyms': ['return on investment', 'return on ad spend'],
            'context': 'ROI > 1.0 means profitable. Use marginal ROI for optimization.'
        },
        'roas': {
            'definition': 'Return on Ad Spend - same as ROI but specific to advertising',
            'formula': 'ROAS = Revenue / Ad Spend',
            'synonyms': ['return on ad spend', 'advertising return'],
            'context': 'Commonly used in digital marketing. ROAS = ROI + 1 in some contexts.'
        },
        'elasticity': {
            'definition': 'Percentage change in sales for 1% change in spend',
            'formula': 'Elasticity = (% Δ Sales) / (% Δ Spend)',
            'synonyms': ['price elasticity', 'advertising elasticity', 'responsiveness'],
            'context': 'Elasticity < 1 means inelastic. Elasticity > 1 means elastic/responsive.'
        },
        'share_of_voice': {
            'definition': 'Your brand\'s share of total market advertising spend',
            'formula': 'SOV = Your Spend / Total Market Spend',
            'synonyms': ['SOV', 'market share of spend', 'advertising share'],
            'context': 'Higher SOV typically correlates with market share growth'
        },
        'cpa': {
            'definition': 'Cost Per Acquisition - spend required to acquire one customer',
            'formula': 'CPA = Spend / Acquisitions',
            'synonyms': ['cost per acquisition', 'cost per conversion', 'CAC'],
            'context': 'Lower CPA is better. Compare to customer lifetime value (LTV).'
        },
        'cpm': {
            'definition': 'Cost Per Mille - cost per 1000 impressions',
            'formula': 'CPM = (Spend / Impressions) × 1000',
            'synonyms': ['cost per thousand', 'impression cost'],
            'context': 'Used for brand awareness campaigns. Varies by channel.'
        },
        'response_curve': {
            'definition': 'Mathematical function showing relationship between spend and response',
            'formula': 'Response = f(Spend) using Hill, logistic, or S-curve',
            'synonyms': ['saturation curve', 'spend response', 'dose-response'],
            'context': 'Hill transformation is most common in modern MMM'
        }
    }
    
    # Channel-specific benchmarks
    CHANNEL_BENCHMARKS = {
        'TV': {
            'typical_roi_range': (0.3, 1.5),
            'typical_roas_range': (1.3, 2.5),
            'typical_saturation': '$500k-$2M per week',
            'adstock_window': '1-4 weeks',
            'diminishing_returns': 'High - TV saturates quickly',
            'best_for': 'Brand awareness, broad reach',
            'seasonality': 'Higher during Q4, sports events'
        },
        'SEARCH': {
            'typical_roi_range': (1.5, 4.0),
            'typical_roas_range': (2.5, 5.0),
            'typical_saturation': '$200k-$1M per week',
            'adstock_window': '1-2 weeks (short)',
            'diminishing_returns': 'Moderate - depends on keyword competition',
            'best_for': 'Performance, direct response',
            'seasonality': 'Holiday spikes (Black Friday, Cyber Monday)'
        },
        'SOCIAL': {
            'typical_roi_range': (1.0, 3.0),
            'typical_roas_range': (2.0, 4.0),
            'typical_saturation': '$100k-$500k per week',
            'adstock_window': '1-3 weeks',
            'diminishing_returns': 'Moderate - platform dependent',
            'best_for': 'Engagement, community building',
            'seasonality': 'Platform-specific events'
        },
        'DISPLAY': {
            'typical_roi_range': (0.5, 2.0),
            'typical_roas_range': (1.5, 3.0),
            'typical_saturation': '$150k-$800k per week',
            'adstock_window': '1-3 weeks',
            'diminishing_returns': 'High - frequency fatigue',
            'best_for': 'Retargeting, brand building',
            'seasonality': 'Q4 surge'
        },
        'RADIO': {
            'typical_roi_range': (0.4, 1.8),
            'typical_roas_range': (1.4, 2.8),
            'typical_saturation': '$100k-$500k per week',
            'adstock_window': '1-3 weeks',
            'diminishing_returns': 'Moderate',
            'best_for': 'Local targeting, commute times',
            'seasonality': 'Morning/evening drive times'
        },
        'VIDEO': {
            'typical_roi_range': (0.8, 2.5),
            'typical_roas_range': (1.8, 3.5),
            'typical_saturation': '$200k-$1M per week',
            'adstock_window': '1-4 weeks',
            'diminishing_returns': 'Moderate to High',
            'best_for': 'Storytelling, product demos',
            'seasonality': 'Q4 holiday season'
        },
        'EMAIL': {
            'typical_roi_range': (3.0, 10.0),
            'typical_roas_range': (4.0, 12.0),
            'typical_saturation': '$10k-$50k per week',
            'adstock_window': '1-2 weeks (immediate)',
            'diminishing_returns': 'Low - highly scalable',
            'best_for': 'Retention, loyalty, direct conversion',
            'seasonality': 'Event-driven (sales, promotions)'
        },
        'OOH': {  # Out-of-Home
            'typical_roi_range': (0.3, 1.2),
            'typical_roas_range': (1.3, 2.2),
            'typical_saturation': '$50k-$300k per week',
            'adstock_window': '2-6 weeks',
            'diminishing_returns': 'Low - location dependent',
            'best_for': 'Local brand awareness',
            'seasonality': 'Weather dependent, high in summer'
        },
    }
    
    # MMM Best Practices
    BEST_PRACTICES = {
        'saturation_detection': {
            'rule': 'If spending above 80% of saturation point, diminishing returns likely',
            'action': 'Reallocate budget to undersaturated channels',
            'citation': 'Hanssens et al., 2001 - Market Response Models'
        },
        'adstock_modeling': {
            'rule': 'Digital channels: 1-2 week adstock. Traditional: 2-6 weeks',
            'action': 'Use geometric decay for adstock transformation',
            'citation': 'Simon & Arndt, 1980 - Advertising Carryover Effects'
        },
        'baseline_contribution': {
            'rule': 'Baseline should account for 30-60% of total sales',
            'action': 'If baseline > 70%, marketing may be underestimated',
            'citation': 'Dekimpe & Hanssens, 1999 - Baseline Sales'
        },
        'budget_allocation': {
            'rule': 'Allocate based on marginal ROI, not average ROI',
            'action': 'Shift budget from saturated to unsaturated channels',
            'citation': 'Danaher & Rust, 1996 - Marketing Mix Optimization'
        },
        'seasonality': {
            'rule': 'Control for seasonality before measuring marketing impact',
            'action': 'Use Fourier terms or seasonal dummies',
            'citation': 'Dekimpe & Hanssens, 1995 - Seasonal Patterns'
        },
        'incrementality': {
            'rule': 'Incremental contribution = Total - Baseline',
            'action': 'Focus on incremental ROI for decision-making',
            'citation': 'Lodish et al., 1995 - Incremental Sales'
        },
        'minimum_spend': {
            'rule': 'Each channel needs minimum threshold spend to be effective',
            'action': 'Avoid spreading budget too thin across many channels',
            'citation': 'Jones, 1995 - Ad Threshold Effects'
        },
        'competitive_effects': {
            'rule': 'Competitor activity affects your marketing effectiveness',
            'action': 'Include share of voice (SOV) in models when possible',
            'citation': 'Danaher et al., 2008 - Share of Voice'
        },
    }
    
    # Diagnostic rules
    DIAGNOSTIC_RULES = {
        'high_saturation': {
            'condition': 'Current spend > 90% saturation point',
            'diagnosis': 'Channel is over-saturated',
            'recommendation': 'Reduce spend by 20-30% and reallocate',
            'urgency': 'high'
        },
        'low_roi': {
            'condition': 'ROI < 1.0',
            'diagnosis': 'Channel is not profitable',
            'recommendation': 'Investigate: (1) Data quality, (2) Attribution window, (3) Phase out channel',
            'urgency': 'high'
        },
        'flat_response': {
            'condition': 'Slope < 0.5',
            'diagnosis': 'Channel has weak response',
            'recommendation': 'Consider creative refresh or better targeting',
            'urgency': 'medium'
        },
        'steep_diminishing_returns': {
            'condition': 'Slope > 3.0',
            'diagnosis': 'Rapid saturation - small optimal range',
            'recommendation': 'Tightly control spend, monitor weekly',
            'urgency': 'medium'
        },
        'unstable_coefficients': {
            'condition': 'Coefficient CV > 50%',
            'diagnosis': 'Unreliable estimates',
            'recommendation': 'Need more data or regularization',
            'urgency': 'high'
        }
    }
    
    # Academic references
    REFERENCES = {
        'market_response_models': {
            'citation': 'Hanssens, D.M., Parsons, L.J., & Schultz, R.L. (2001). Market Response Models.',
            'summary': 'Foundational text on econometric modeling of marketing effectiveness',
            'url': 'https://scholar.google.com/scholar?q=Hanssens+Market+Response+Models'
        },
        'mmm_overview': {
            'citation': 'Albers, S., Mantrala, M.K., & Sridhar, S. (2010). Personal Selling Elasticities.',
            'summary': 'Meta-analysis of marketing elasticities across channels',
            'url': 'https://scholar.google.com/scholar?q=Albers+Marketing+Elasticities'
        },
        'bayesian_mmm': {
            'citation': 'Jin, Y., Wang, Y., Sun, Y., Chan, D., & Koehler, J. (2017). Bayesian Methods for MMM.',
            'summary': 'Bayesian hierarchical models for marketing mix',
            'url': 'https://research.google/pubs/pub46001/'
        },
        'causal_inference': {
            'citation': 'Brodersen, K.H., et al. (2015). Inferring Causal Impact Using Bayesian Structural Time-Series Models.',
            'summary': 'Causal inference for marketing interventions',
            'url': 'https://research.google.com/pubs/pub41854.html'
        }
    }
    
    @classmethod
    def get_channel_benchmark(cls, channel: str) -> Dict:
        """
        Get benchmark data for a channel.
        
        Parameters
        ----------
        channel : str
            Channel name (case-insensitive)
            
        Returns
        -------
        Dict
            Benchmark data
        """
        channel_upper = channel.upper()
        
        if channel_upper in cls.CHANNEL_BENCHMARKS:
            return cls.CHANNEL_BENCHMARKS[channel_upper]
        
        # Return generic benchmark
        return {
            'typical_roi_range': (0.5, 2.5),
            'typical_roas_range': (1.5, 3.5),
            'typical_saturation': 'Varies by channel',
            'adstock_window': '1-3 weeks',
            'diminishing_returns': 'Moderate',
            'best_for': 'Depends on objectives',
            'seasonality': 'Channel-specific'
        }
    
    @classmethod
    def get_best_practice(cls, topic: str) -> Dict:
        """Get best practice for a topic"""
        return cls.BEST_PRACTICES.get(topic, {})
    
    @classmethod
    def diagnose(cls, metric: str, value: float, context: Dict = None) -> List[Dict]:
        """
        Diagnose issues based on metrics.
        
        Parameters
        ----------
        metric : str
            Metric name ('roi', 'saturation', 'slope', etc.)
        value : float
            Metric value
        context : Dict, optional
            Additional context (saturation point, etc.)
            
        Returns
        -------
        List[Dict]
            List of diagnostic findings
        """
        findings = []
        
        if metric == 'roi' and value < 1.0:
            findings.append(cls.DIAGNOSTIC_RULES['low_roi'])
        
        if metric == 'slope' and value < 0.5:
            findings.append(cls.DIAGNOSTIC_RULES['flat_response'])
        
        if metric == 'slope' and value > 3.0:
            findings.append(cls.DIAGNOSTIC_RULES['steep_diminishing_returns'])
        
        if metric == 'saturation_pct' and value > 0.9:
            findings.append(cls.DIAGNOSTIC_RULES['high_saturation'])
        
        return findings
    
    @classmethod
    def compare_to_benchmark(cls, channel: str, roi: float) -> str:
        """
        Compare channel ROI to industry benchmark.
        
        Parameters
        ----------
        channel : str
            Channel name
        roi : float
            Observed ROI
            
        Returns
        -------
        str
            Comparison summary
        """
        benchmark = cls.get_channel_benchmark(channel)
        roi_range = benchmark.get('typical_roi_range', (0.5, 2.5))
        
        if roi < roi_range[0]:
            return f"Below benchmark. Typical {channel} ROI: {roi_range[0]:.1f}-{roi_range[1]:.1f}x. Consider optimization."
        elif roi > roi_range[1]:
            return f"Above benchmark! Typical {channel} ROI: {roi_range[0]:.1f}-{roi_range[1]:.1f}x. Strong performance."
        else:
            return f"Within benchmark range. Typical {channel} ROI: {roi_range[0]:.1f}-{roi_range[1]:.1f}x."
    
    @classmethod
    def get_all_best_practices(cls) -> List[Dict]:
        """Get all best practices as list"""
        return [
            {'topic': topic, **details}
            for topic, details in cls.BEST_PRACTICES.items()
        ]
    
    @classmethod
    def get_reference(cls, topic: str) -> Dict:
        """Get academic reference for a topic"""
        return cls.REFERENCES.get(topic, {})
    
    @classmethod
    def get_contextual_advice(cls, query: str, channel_data: Dict) -> str:
        """
        Generate contextual advice based on query and data.
        
        Parameters
        ----------
        query : str
            User query
        channel_data : Dict
            Channel performance data
            
        Returns
        -------
        str
            Contextual advice
        """
        query_lower = query.lower()
        advice = []
        
        # Saturation-related queries
        if any(word in query_lower for word in ['saturated', 'saturation', 'maxed out']):
            practice = cls.BEST_PRACTICES['saturation_detection']
            advice.append(f"Best Practice: {practice['rule']} ({practice['citation']})")
        
        # Budget allocation queries
        if any(word in query_lower for word in ['allocate', 'budget', 'spend', 'optimize']):
            practice = cls.BEST_PRACTICES['budget_allocation']
            advice.append(f"Best Practice: {practice['rule']} ({practice['citation']})")
        
        # ROI queries
        if 'roi' in query_lower or 'return' in query_lower:
            practice = cls.BEST_PRACTICES['incrementality']
            advice.append(f"Best Practice: {practice['rule']} ({practice['citation']})")
        
        return "\n".join(advice) if advice else ""

